import {
  Cookies,
  createEventHook,
  identity,
  isClient,
  noop,
  notNullish,
  toArray,
  toRef,
  tryOnMounted,
  tryOnScopeDispose,
  until,
  watchPausable
} from "./chunk-R57JGUFW.js";
import {
  AxiosError,
  axios_default
} from "./chunk-IAPECSFJ.js";
import {
  computed,
  isRef,
  nextTick,
  ref,
  shallowRef,
  toRaw,
  toValue,
  watch,
  watchEffect
} from "./chunk-FIAHBV72.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// optional-peer-dep:__vite-optional-peer-dep:async-validator:@vueuse/integrations:false
var require_integrations_false = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:async-validator:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "async-validator" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:change-case:@vueuse/integrations:false
var require_integrations_false2 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:change-case:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "change-case" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:drauu:@vueuse/integrations:false
var require_integrations_false3 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:drauu:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "drauu" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:focus-trap:@vueuse/integrations:false
var require_integrations_false4 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:focus-trap:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "focus-trap" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:fuse.js:@vueuse/integrations:false
var require_integrations_false5 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:fuse.js:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "fuse.js" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:idb-keyval:@vueuse/integrations:false
var require_integrations_false6 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:idb-keyval:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "idb-keyval" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:jwt-decode:@vueuse/integrations:false
var require_integrations_false7 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:jwt-decode:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "jwt-decode" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:nprogress:@vueuse/integrations:false
var require_integrations_false8 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:nprogress:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "nprogress" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:qrcode:@vueuse/integrations:false
var require_integrations_false9 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:qrcode:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "qrcode" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:sortablejs:@vueuse/integrations:false
var require_integrations_false10 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:sortablejs:@vueuse/integrations:false"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "sortablejs" imported by "@vueuse/integrations". Is it installed?`);
  }
});

// node_modules/@vueuse/integrations/index.mjs
var import_async_validator = __toESM(require_integrations_false(), 1);
var changeCase = __toESM(require_integrations_false2(), 1);

// node_modules/@vueuse/core/index.mjs
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);

// node_modules/@vueuse/integrations/index.mjs
var import_drauu = __toESM(require_integrations_false3(), 1);
var import_focus_trap = __toESM(require_integrations_false4(), 1);
var import_fuse = __toESM(require_integrations_false5(), 1);
var import_idb_keyval = __toESM(require_integrations_false6(), 1);
var import_jwt_decode = __toESM(require_integrations_false7(), 1);
var import_nprogress = __toESM(require_integrations_false8(), 1);
var import_qrcode = __toESM(require_integrations_false9(), 1);
var import_sortablejs = __toESM(require_integrations_false10(), 1);
var AsyncValidatorSchema = import_async_validator.default.default || import_async_validator.default;
function useAsyncValidator(value, rules, options = {}) {
  const {
    validateOption = {},
    immediate = true,
    manual = false
  } = options;
  const valueRef = toRef(value);
  const errorInfo = shallowRef(null);
  const isFinished = shallowRef(true);
  const pass = shallowRef(!immediate || manual);
  const errors = computed(() => {
    var _a;
    return ((_a = errorInfo.value) == null ? void 0 : _a.errors) || [];
  });
  const errorFields = computed(() => {
    var _a;
    return ((_a = errorInfo.value) == null ? void 0 : _a.fields) || {};
  });
  const validator = computed(() => new AsyncValidatorSchema(toValue(rules)));
  const execute = async () => {
    isFinished.value = false;
    pass.value = false;
    try {
      await validator.value.validate(valueRef.value, validateOption);
      pass.value = true;
      errorInfo.value = null;
    } catch (err) {
      errorInfo.value = err;
    } finally {
      isFinished.value = true;
    }
    return {
      pass: pass.value,
      errorInfo: errorInfo.value,
      errors: errors.value,
      errorFields: errorFields.value
    };
  };
  if (!manual) {
    watch(
      [valueRef, validator],
      () => execute(),
      { immediate, deep: true }
    );
  }
  const shell = {
    isFinished,
    pass,
    errors,
    errorInfo,
    errorFields,
    execute
  };
  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error) => reject(error));
    });
  }
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
function useAxios(...args) {
  const url = typeof args[0] === "string" ? args[0] : void 0;
  const argsPlaceholder = typeof url === "string" ? 1 : 0;
  const defaultOptions = {
    immediate: !!argsPlaceholder,
    shallow: true,
    abortPrevious: true
  };
  let defaultConfig = {};
  let instance = axios_default;
  let options = defaultOptions;
  const isAxiosInstance = (val) => !!(val == null ? void 0 : val.request);
  if (args.length > 0 + argsPlaceholder) {
    if (isAxiosInstance(args[0 + argsPlaceholder]))
      instance = args[0 + argsPlaceholder];
    else
      defaultConfig = args[0 + argsPlaceholder];
  }
  if (args.length > 1 + argsPlaceholder) {
    if (isAxiosInstance(args[1 + argsPlaceholder]))
      instance = args[1 + argsPlaceholder];
  }
  if (args.length === 2 + argsPlaceholder && !isAxiosInstance(args[1 + argsPlaceholder]) || args.length === 3 + argsPlaceholder) {
    options = args[args.length - 1] || defaultOptions;
  }
  const {
    shallow,
    onSuccess = noop,
    onError = noop,
    immediate,
    resetOnExecute = false
  } = options;
  const initialData = options.initialData;
  const response = shallowRef();
  const data = (shallow ? shallowRef : ref)(initialData);
  const isFinished = shallowRef(false);
  const isLoading = shallowRef(false);
  const isAborted = shallowRef(false);
  const error = shallowRef();
  let abortController = new AbortController();
  const abort = (message) => {
    if (isFinished.value || !isLoading.value)
      return;
    abortController.abort(message);
    abortController = new AbortController();
    isAborted.value = true;
    isLoading.value = false;
    isFinished.value = false;
  };
  const loading = (loading2) => {
    isLoading.value = loading2;
    isFinished.value = !loading2;
  };
  const resetData = () => {
    if (resetOnExecute)
      data.value = initialData;
  };
  const waitUntilFinished = () => new Promise((resolve, reject) => {
    until(isFinished).toBe(true).then(() => error.value ? reject(error.value) : resolve(result));
  });
  const promise = {
    then: (...args2) => waitUntilFinished().then(...args2),
    catch: (...args2) => waitUntilFinished().catch(...args2)
  };
  let executeCounter = 0;
  const execute = (executeUrl = url, config = {}) => {
    error.value = void 0;
    const _url = typeof executeUrl === "string" ? executeUrl : url != null ? url : config.url;
    if (_url === void 0) {
      error.value = new AxiosError(AxiosError.ERR_INVALID_URL);
      isFinished.value = true;
      return promise;
    }
    resetData();
    if (options.abortPrevious !== false)
      abort();
    loading(true);
    executeCounter += 1;
    const currentExecuteCounter = executeCounter;
    isAborted.value = false;
    instance(_url, { ...defaultConfig, ...typeof executeUrl === "object" ? executeUrl : config, signal: abortController.signal }).then((r) => {
      if (isAborted.value)
        return;
      response.value = r;
      const result2 = r.data;
      data.value = result2;
      onSuccess(result2);
    }).catch((e) => {
      error.value = e;
      onError(e);
    }).finally(() => {
      var _a;
      (_a = options.onFinish) == null ? void 0 : _a.call(options);
      if (currentExecuteCounter === executeCounter)
        loading(false);
    });
    return promise;
  };
  if (immediate && url)
    execute();
  const result = {
    response,
    data,
    error,
    isFinished,
    isLoading,
    cancel: abort,
    isAborted,
    isCanceled: isAborted,
    abort,
    execute
  };
  return {
    ...result,
    ...promise
  };
}
var changeCaseTransforms = Object.entries(changeCase).filter(([name, fn]) => typeof fn === "function" && name.endsWith("Case")).reduce((acc, [name, fn]) => {
  acc[name] = fn;
  return acc;
}, {});
function useChangeCase(input, type, options) {
  const typeRef = computed(() => {
    const t = toValue(type);
    if (!changeCaseTransforms[t])
      throw new Error(`Invalid change case type "${t}"`);
    return t;
  });
  if (typeof input === "function")
    return computed(() => changeCaseTransforms[typeRef.value](toValue(input), toValue(options)));
  const text = ref(input);
  return computed({
    get() {
      return changeCaseTransforms[typeRef.value](text.value, toValue(options));
    },
    set(value) {
      text.value = value;
    }
  });
}
function createCookies(req) {
  const universalCookie = new Cookies(req ? req.headers.cookie : null);
  return (dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}) => useCookies(dependencies, { doNotParse, autoUpdateDependencies }, universalCookie);
}
function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookies()) {
  const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
  let previousCookies = cookies.getAll({ doNotParse: true });
  const touches = shallowRef(0);
  const onChange = () => {
    const newCookies = cookies.getAll({ doNotParse: true });
    if (shouldUpdate(
      watchingDependencies || null,
      newCookies,
      previousCookies
    )) {
      touches.value++;
    }
    previousCookies = newCookies;
  };
  cookies.addChangeListener(onChange);
  tryOnScopeDispose(() => {
    cookies.removeChangeListener(onChange);
  });
  return {
    /**
     * Reactive get cookie by name. If **autoUpdateDependencies = true** then it will update watching dependencies
     */
    get: (...args) => {
      if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
        watchingDependencies.push(args[0]);
      touches.value;
      return cookies.get(args[0], { doNotParse, ...args[1] });
    },
    /**
     * Reactive get all cookies
     */
    getAll: (...args) => {
      touches.value;
      return cookies.getAll({ doNotParse, ...args[0] });
    },
    set: (...args) => cookies.set(...args),
    remove: (...args) => cookies.remove(...args),
    addChangeListener: (...args) => cookies.addChangeListener(...args),
    removeChangeListener: (...args) => cookies.removeChangeListener(...args)
  };
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
  if (!dependencies)
    return true;
  for (const dependency of dependencies) {
    if (newCookies[dependency] !== oldCookies[dependency])
      return true;
  }
  return false;
}
function useDrauu(target, options) {
  const drauuInstance = ref();
  let disposables = [];
  const onChangedHook = createEventHook();
  const onCanceledHook = createEventHook();
  const onCommittedHook = createEventHook();
  const onStartHook = createEventHook();
  const onEndHook = createEventHook();
  const canUndo = shallowRef(false);
  const canRedo = shallowRef(false);
  const altPressed = shallowRef(false);
  const shiftPressed = shallowRef(false);
  const brush = ref({
    color: "black",
    size: 3,
    arrowEnd: false,
    cornerRadius: 0,
    dasharray: void 0,
    fill: "transparent",
    mode: "draw",
    ...options == null ? void 0 : options.brush
  });
  watch(brush, () => {
    const instance = drauuInstance.value;
    if (instance) {
      instance.brush = brush.value;
      instance.mode = brush.value.mode;
    }
  }, { deep: true });
  const undo = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.undo();
  };
  const redo = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.redo();
  };
  const clear = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.clear();
  };
  const cancel = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.cancel();
  };
  const load = (svg) => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.load(svg);
  };
  const dump = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.dump();
  };
  const cleanup = () => {
    var _a;
    disposables.forEach((dispose) => dispose());
    (_a = drauuInstance.value) == null ? void 0 : _a.unmount();
  };
  const syncStatus = () => {
    if (drauuInstance.value) {
      canUndo.value = drauuInstance.value.canUndo();
      canRedo.value = drauuInstance.value.canRedo();
      altPressed.value = drauuInstance.value.altPressed;
      shiftPressed.value = drauuInstance.value.shiftPressed;
    }
  };
  watch(
    () => unrefElement(target),
    (el) => {
      if (!el || typeof SVGSVGElement === "undefined" || !(el instanceof SVGSVGElement))
        return;
      if (drauuInstance.value)
        cleanup();
      drauuInstance.value = (0, import_drauu.createDrauu)({ el, ...options });
      syncStatus();
      disposables = [
        drauuInstance.value.on("canceled", () => onCanceledHook.trigger()),
        drauuInstance.value.on("committed", (node) => onCommittedHook.trigger(node)),
        drauuInstance.value.on("start", () => onStartHook.trigger()),
        drauuInstance.value.on("end", () => onEndHook.trigger()),
        drauuInstance.value.on("changed", () => {
          syncStatus();
          onChangedHook.trigger();
        })
      ];
    },
    { flush: "post" }
  );
  tryOnScopeDispose(() => cleanup());
  return {
    drauuInstance,
    load,
    dump,
    clear,
    cancel,
    undo,
    redo,
    canUndo,
    canRedo,
    brush,
    onChanged: onChangedHook.on,
    onCommitted: onCommittedHook.on,
    onStart: onStartHook.on,
    onEnd: onEndHook.on,
    onCanceled: onCanceledHook.on
  };
}
function useFocusTrap(target, options = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = options;
  const hasFocus = shallowRef(false);
  const isPaused = shallowRef(false);
  const activate = (opts) => trap && trap.activate(opts);
  const deactivate = (opts) => trap && trap.deactivate(opts);
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.value = true;
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.value = false;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target);
    return toArray(_targets).map((el) => {
      const _el = toValue(el);
      return typeof _el === "string" ? _el : unrefElement(_el);
    }).filter(notNullish);
  });
  watch(
    targets,
    (els) => {
      if (!els.length)
        return;
      if (!trap) {
        trap = (0, import_focus_trap.createFocusTrap)(els, {
          ...focusTrapOptions,
          onActivate() {
            hasFocus.value = true;
            if (options.onActivate)
              options.onActivate();
          },
          onDeactivate() {
            hasFocus.value = false;
            if (options.onDeactivate)
              options.onDeactivate();
          }
        });
        if (immediate)
          activate();
      } else {
        const isActive = trap == null ? void 0 : trap.active;
        trap == null ? void 0 : trap.updateContainerElements(els);
        if (!isActive && immediate) {
          activate();
        }
      }
    },
    { flush: "post" }
  );
  tryOnScopeDispose(() => deactivate());
  return {
    hasFocus,
    isPaused,
    activate,
    deactivate,
    pause,
    unpause
  };
}
function useFuse(search, data, options) {
  const createFuse = () => {
    var _a, _b;
    return new import_fuse.default(
      (_a = toValue(data)) != null ? _a : [],
      (_b = toValue(options)) == null ? void 0 : _b.fuseOptions
    );
  };
  const fuse = ref(createFuse());
  watch(
    () => {
      var _a;
      return (_a = toValue(options)) == null ? void 0 : _a.fuseOptions;
    },
    () => {
      fuse.value = createFuse();
    },
    { deep: true }
  );
  watch(
    () => toValue(data),
    (newData) => {
      fuse.value.setCollection(newData);
    },
    { deep: true }
  );
  const results = computed(() => {
    const resolved = toValue(options);
    if ((resolved == null ? void 0 : resolved.matchAllWhenSearchEmpty) && !toValue(search))
      return toValue(data).map((item, index) => ({ item, refIndex: index }));
    const limit = resolved == null ? void 0 : resolved.resultLimit;
    return fuse.value.search(toValue(search), limit ? { limit } : void 0);
  });
  return {
    fuse,
    results
  };
}
function useIDBKeyval(key, initialValue, options = {}) {
  const {
    flush = "pre",
    deep = true,
    shallow = false,
    onError = (e) => {
      console.error(e);
    },
    writeDefaults = true,
    serializer = {
      read: (raw) => raw,
      write: (value) => value
    }
  } = options;
  const isFinished = shallowRef(false);
  const data = (shallow ? shallowRef : ref)(initialValue);
  const rawInit = toValue(initialValue);
  async function read() {
    try {
      const rawValue = await (0, import_idb_keyval.get)(key);
      if (rawValue === void 0) {
        if (rawInit !== void 0 && rawInit !== null && writeDefaults) {
          const initValue = serializer.write(rawInit);
          await (0, import_idb_keyval.set)(key, initValue);
        }
      } else {
        data.value = serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
    isFinished.value = true;
  }
  read();
  async function write() {
    try {
      if (data.value == null) {
        await (0, import_idb_keyval.del)(key);
      } else {
        const rawValue = toRaw(data.value);
        const serializedValue = serializer.write(rawValue);
        await (0, import_idb_keyval.update)(key, () => serializedValue);
      }
    } catch (e) {
      onError(e);
    }
  }
  const {
    pause: pauseWatch,
    resume: resumeWatch
  } = watchPausable(data, () => write(), { flush, deep });
  async function setData(value) {
    pauseWatch();
    data.value = value;
    await write();
    resumeWatch();
  }
  return {
    set: setData,
    isFinished,
    data
  };
}
function useJwt(encodedJwt, options = {}) {
  const {
    onError,
    fallbackValue = null
  } = options;
  const decodeWithFallback = (encodedJwt2, options2) => {
    try {
      return (0, import_jwt_decode.jwtDecode)(encodedJwt2, options2);
    } catch (err) {
      onError == null ? void 0 : onError(err);
      return fallbackValue;
    }
  };
  const header = computed(() => decodeWithFallback(toValue(encodedJwt), { header: true }));
  const payload = computed(() => decodeWithFallback(toValue(encodedJwt)));
  return {
    header,
    payload
  };
}
function useNProgress(currentProgress = null, options) {
  const progress = toRef(currentProgress);
  const isLoading = computed({
    set: (load) => load ? import_nprogress.default.start() : import_nprogress.default.done(),
    get: () => typeof progress.value === "number" && progress.value < 1
  });
  if (options)
    import_nprogress.default.configure(options);
  const setProgress = import_nprogress.default.set;
  import_nprogress.default.set = (n) => {
    progress.value = n;
    return setProgress.call(import_nprogress.default, n);
  };
  watchEffect(() => {
    if (typeof progress.value === "number" && isClient)
      setProgress.call(import_nprogress.default, progress.value);
  });
  tryOnScopeDispose(import_nprogress.default.remove);
  return {
    isLoading,
    progress,
    start: import_nprogress.default.start,
    done: import_nprogress.default.done,
    remove: () => {
      progress.value = null;
      import_nprogress.default.remove();
    }
  };
}
function useQRCode(text, options) {
  const src = toRef(text);
  const result = shallowRef("");
  watch(
    src,
    async (value) => {
      if (src.value && isClient)
        result.value = await import_qrcode.default.toDataURL(value, options);
    },
    { immediate: true }
  );
  return result;
}
function useSortable(el, list, options = {}) {
  let sortable;
  const { document: document2 = defaultDocument, ...resetOptions } = options;
  const defaultOptions = {
    onUpdate: (e) => {
      moveArrayElement(list, e.oldIndex, e.newIndex, e);
    }
  };
  const start = () => {
    const target = typeof el === "string" ? document2 == null ? void 0 : document2.querySelector(el) : unrefElement(el);
    if (!target || sortable !== void 0)
      return;
    sortable = new import_sortablejs.default(target, { ...defaultOptions, ...resetOptions });
  };
  const stop = () => {
    sortable == null ? void 0 : sortable.destroy();
    sortable = void 0;
  };
  const option = (name, value) => {
    if (value !== void 0)
      sortable == null ? void 0 : sortable.option(name, value);
    else
      return sortable == null ? void 0 : sortable.option(name);
  };
  tryOnMounted(start);
  tryOnScopeDispose(stop);
  return {
    stop,
    start,
    option
  };
}
function insertNodeAt(parentElement, element, index) {
  const refElement = parentElement.children[index];
  parentElement.insertBefore(element, refElement);
}
function removeNode(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
}
function moveArrayElement(list, from, to, e = null) {
  if (e != null) {
    removeNode(e.item);
    insertNodeAt(e.from, e.item, from);
  }
  const _valueIsRef = isRef(list);
  const array = _valueIsRef ? [...toValue(list)] : toValue(list);
  if (to >= 0 && to < array.length) {
    const element = array.splice(from, 1)[0];
    nextTick(() => {
      array.splice(to, 0, element);
      if (_valueIsRef)
        list.value = array;
    });
  }
}
export {
  createCookies,
  insertNodeAt,
  moveArrayElement,
  removeNode,
  useAsyncValidator,
  useAxios,
  useChangeCase,
  useCookies,
  useDrauu,
  useFocusTrap,
  useFuse,
  useIDBKeyval,
  useJwt,
  useNProgress,
  useQRCode,
  useSortable
};
//# sourceMappingURL=@vueuse_integrations.js.map
